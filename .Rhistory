workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant)
names(data)
fwd.model <- regsubsets(x = data[,1:14], y = data[,15], nvmax = 10000, method = 'forward', really.big = TRUE)
fwd.model <- regsubsets(x = select(data, -cnt), y = select(data, cnt), nvmax = 10000, method = 'forward', really.big = TRUE)
fwd.model <- regsubsets(x = select(data, -cnt), y = select(data, cnt), nvmax = 1000, method = 'forward', really.big = TRUE)
sapply(data, is.factor)
fwd.model <- regsubsets(x = select(data, -cnt, -workingday), y = select(data, cnt), nvmax = 1000, method = 'forward', really.big = TRUE)
fwd.model <- regsubsets(x = select(data, -cnt, -workingday), y = select(data, cnt), nvmax = 1000, method = 'forward', really.big = TRUE)
select(data, -cnt)
select(data, cnt)
data <- as.data.frame(read_csv('day.csv'))
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
class(data)
fwd.model <- regsubsets(x = select(data, -cnt), y = select(data, cnt), nvmax = 1000, method = 'forward', really.big = TRUE)
names(data)
fwd.model <- regsubsets(cnt ~ ., data = data, nvmax = 1000, method = 'forward', really.big = TRUE)
summary(fwd.model)
library(olsrr)
fwd.model <- ols_step_forward_p(model)
summary(model)
model <- lm(cnt ~ . -workingday , data = data)
summary(model)
model <- lm(cnt ~ . -workingday -dteday , data = data)
model <- lm(cnt ~ . -workingday, -dteday , data = data)
model <- lm(cnt ~ . c(-workingday, -dteday), data = data)
data <- data %>% select(-instant, -workingday)
model <- lm(cnt ~ ., -dteday , data = data)
model <- lm(cnt ~ . , data = data)
summary(model)
data <- as.data.frame(read_csv('day.csv'))
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant, -workingday)
model <- lm(cnt ~ . , data = data)
summary(model)
fwd.model <- ols_step_forward_p(model)
fwd.model <- regsubsets(cnt ~ ., data = data, nvmax = 1000, method = 'forward', really.big = TRUE)
data <- as.data.frame(read_csv('day.csv'))
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant)
model <- lm(cnt ~ . , data = data)
summary(model)
data <- data %>% select(-workingday)
model <- lm(cnt ~ . , data = data)
summary(model)
data <- as.data.frame(read_csv('day.csv'))
pairs(data)
cor(data)
cor(data$temp, data$atemp)
data <- as.data.frame(read_csv('day.csv'))
cor(data$temp, data$atemp)
cor(data)
names(data)
cor(select(-instant, -dteday))
cor(select(data, -instant, -dteday))
data <- as.data.frame(read_csv('day.csv'))
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant)
sapply(data, class)
pairs(data)
corrplot::corrplot(data)
cor(select(data, -instant, -dteday))
cor(data.old)
data.old <- data
cor(data.old)
data.old <- select(data, -instant, -dteday)
data <- as.data.frame(read_csv('day.csv'))
data.old <- data
data.old <- select(data, -instant, -dteday)
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant)
cor(data.old)
cor(data$season, data$mnth)
cor(data.old$season, data.old$mnth)
cor(data.old$temp, data.old$atemp)
cor(data.old$registered, data.old$cnt)
data <- as.data.frame(read_csv('day.csv'))
data.old <- data
data.old <- select(data, -instant, -dteday)
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant)
model <- lm(cnt ~ . , data = data)
summary(model)
data <- data %>% select(-instant, -dteday)
data <- as.data.frame(read_csv('day.csv'))
data.old <- data
data.old <- select(data, -instant, -dteday)
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant, -dteday)
sapply(data, class)
cor(data.old)
cor(data.old$registered, data.old$cnt)
cor(data.old$casual, data.old$registered)
cor(data.old$season, data.old$mnth)
cor(data.old$temp, data.old$atemp)
cor(data.old$registered, data.old$cnt)
cor(data.old$casual, data.old$registered)
model <- lm(cnt ~ . , data = data)
summary(model)
summary(model)
data <- data %>% select(-workingday)
model <- lm(cnt ~ . , data = data)
summary(model)
summary(model)
data <- data %>% select(-workingday, -casual, -registered)
data <- as.data.frame(read_csv('day.csv'))
data.old <- data
data.old <- select(data, -instant, -dteday)
class(data)
str(data)
str(data)
summary(data)
table(data$weathersit)
data <- data %>% mutate(
season = factor(season, levels = c(1,2,3,4), labels = c('Springer', 'Summer', 'Fall', 'Winter')),
yr = factor(yr, levels = c(0,1), labels = c('2011', '2012')),
mnth = factor(mnth, levels = c(1:12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")),
holiday = factor(holiday, levels = c(0,1), labels = c('No', 'Yes')),
weekday = factor(weekday, levels = c(0:6), labels = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')),
workingday = factor(workingday, levels = c(0,1), labels = c('No', 'Yes')),
weathersit = factor(weathersit, levels = c(1,2,3,4), labels = c('Clear', 'Mist', 'Light Snow', 'Heavy Rain')),
casual = as.integer(casual),
registered = as.integer(registered),
cnt = as.integer(cnt)
)
data <- data %>% select(-instant, -dteday)
data <- data %>% select(-workingday, -casual, -registered)
model <- lm(cnt ~ . , data = data)
summary(model)
library(tidyverse)
library(lubridate)
library(xts)
library(forecast)
setParams <- function(productName = NA, frequencyTs = NA, startTs = NA){
# Funcion para establecer los parametros globales
# productName: nombre del producto
# frequencyTs: periodicidad de la serie de tiempo
# startTs: fecha de inicio de la serie de tiempo
product <- productName
frequency <- frequencyTs
start <- startTs
return(list(product = product, frequency = frequency, start = start))
}
init <- function(globalParams){
# Funcion para validar que hayan llegado todos los parametros
#globalParams: vector que contiene los parametros globales obligatorios
#1. product, 2. frequency, 3. start
flag = FALSE
if(is.na(globalParams$product) || is.na(globalParams$frequency) || is.na(globalParams$start)){
print('PARAR LA EJECUCION')
flag = FALSE
}else{
print('Everything is ok! Has fun!')
flag = TRUE
}
return(flag)
}
# Load Data
loadData <- function(){
# Capturar con soap
# Funcion para cargar los datos
data <- read_csv2('datasemanal.csv', locale = locale(encoding = "Latin1"))
data
}
# Filter Data
filterData <- function(productName){
# Filtramos por nombre.
data <- data %>% filter(artiNombre == productName)
data
}
prepareData <- function(){
#CAMBIAR
data <- data %>% mutate(
artiId = as.character(artiId),
artiNombre = as.character(artiNombre),
fechaIni = lubridate::as_date(fechaIni),
maximoKg = as.double(maximoKg),
minimoKg = as.double(minimoKg),
promedioKg = as.double(promedioKg)
)
#Sort
data <- data %>% arrange(fechaIni)
data
}
createTimeSeries <- function(target, globalParamsP){
#target: variable objeto de estudio
data.ts <- ts(data[,target], start = globalParamsP$start, frequency = globalParamsP$frequency)
data.ts
}
splitData <- function(data, percentage = .3){
#Funcion para cortar los datos
#data: datos en formato ts o xts
#percentage: porcentaje de datos a utilizar como test
h <- round(length(data) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
test <- data.ts[(th+1):(th+h),]
return(list(train = train, test = test, h = h, th = th))
}
#
trainingModelsMoving <- function(h, th, data){
#Funcion para entrenar los modelos usando una ventana movil
#h: tamaño del horizonte (cuantos periodos usamos como test)
#th: periodos en los datos de train
#data: todos los datos
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
#holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
#holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal
#'holtWinterAditivo' = holtWinterAditivo,
#'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
evaluateModels <- function(models, test){
# Funcion para evaluar el rendimiento de los modelos frente a los datos de test
#models: lista de pronosticos de los modelos evaluados anteriormente
#test: datos de test
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
r <- rbind(accuracy(models$suavizacionExponencialSimple, test)["Test set", metrics],
accuracy(models$suavizacionExponencialLineal, test)["Test set", metrics])
metricas <- data.frame(r)
row.names(metricas) <- c("SES", "HOLT")
return(metricas)
}
compareModels <- fucntion(metrics){
#PARAMETRIZAR LA ELECCION DE LA METRICA
#Funcion para comparar los modelos previamente evaluados. Esta retorna el mejor modelo y su indice en el arr
#metrics: dataframe que contiene todas las metricas de evaluacion de cada modelo
#indexMetrics = list("ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5)
indexMinValue <- which.min(metrics$RMSE)
bestModel <- metrics[indexMinValue,]
row.names(resultMetrics[indexMinValue,])
return(list(bestModel = bestModel, indexMinValue = indexMinValue))
}
#Start
globalParams <- setParams(productName = 'Queso costeño',
frequencyTs = 365.25/7,
startTs = decimal_date(ymd("2020-02-01")))
globalParams
if(init(globalParams = globalParams)){
data <- loadData()
data <- filterData(globalParams$product)
data <- prepareData()
# Mientras tanto
#lo de abajo reemplazarlo con createdataframe una vez se descargue full data y evitar el error
#data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
splitDataResult <- splitData(data = data.ts, percentage = .3)
train <- splitDataResult$train
test <- splitDataResult$test
h <- splitDataResult$h
th <- splitDataResult$th
results <- trainingModelsMoving(h, th, data.ts)
resultMetrics <- evaluateModels(results, test)
bestModelo <- compareModels(results)
#percentage <- .3
#h <- round(length(data.ts) * percentage)
#th <- length(data.ts) - h
}else{
print('Some parameter is missing')
#api.response(200, 'data is missing')
return(FALSE)
}
setwd("~/Mario/Dev/Analítica/SIPSA")
library(tidyverse)
library(lubridate)
library(xts)
library(forecast)
setParams <- function(productName = NA, frequencyTs = NA, startTs = NA){
# Funcion para establecer los parametros globales
# productName: nombre del producto
# frequencyTs: periodicidad de la serie de tiempo
# startTs: fecha de inicio de la serie de tiempo
product <- productName
frequency <- frequencyTs
start <- startTs
return(list(product = product, frequency = frequency, start = start))
}
init <- function(globalParams){
# Funcion para validar que hayan llegado todos los parametros
#globalParams: vector que contiene los parametros globales obligatorios
#1. product, 2. frequency, 3. start
flag = FALSE
if(is.na(globalParams$product) || is.na(globalParams$frequency) || is.na(globalParams$start)){
print('PARAR LA EJECUCION')
flag = FALSE
}else{
print('Everything is ok! Has fun!')
flag = TRUE
}
return(flag)
}
# Load Data
loadData <- function(){
# Capturar con soap
# Funcion para cargar los datos
data <- read_csv2('datasemanal.csv', locale = locale(encoding = "Latin1"))
data
}
# Filter Data
filterData <- function(productName){
# Filtramos por nombre.
data <- data %>% filter(artiNombre == productName)
data
}
prepareData <- function(){
#CAMBIAR
data <- data %>% mutate(
artiId = as.character(artiId),
artiNombre = as.character(artiNombre),
fechaIni = lubridate::as_date(fechaIni),
maximoKg = as.double(maximoKg),
minimoKg = as.double(minimoKg),
promedioKg = as.double(promedioKg)
)
#Sort
data <- data %>% arrange(fechaIni)
data
}
createTimeSeries <- function(target, globalParamsP){
#target: variable objeto de estudio
data.ts <- ts(data[,target], start = globalParamsP$start, frequency = globalParamsP$frequency)
data.ts
}
splitData <- function(data, percentage = .3){
#Funcion para cortar los datos
#data: datos en formato ts o xts
#percentage: porcentaje de datos a utilizar como test
h <- round(length(data) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
test <- data.ts[(th+1):(th+h),]
return(list(train = train, test = test, h = h, th = th))
}
#
trainingModelsMoving <- function(h, th, data){
#Funcion para entrenar los modelos usando una ventana movil
#h: tamaño del horizonte (cuantos periodos usamos como test)
#th: periodos en los datos de train
#data: todos los datos
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
#holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
#holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal
#'holtWinterAditivo' = holtWinterAditivo,
#'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
evaluateModels <- function(models, test){
# Funcion para evaluar el rendimiento de los modelos frente a los datos de test
#models: lista de pronosticos de los modelos evaluados anteriormente
#test: datos de test
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
r <- rbind(accuracy(models$suavizacionExponencialSimple, test)["Test set", metrics],
accuracy(models$suavizacionExponencialLineal, test)["Test set", metrics])
metricas <- data.frame(r)
row.names(metricas) <- c("SES", "HOLT")
return(metricas)
}
compareModels <- fucntion(metrics){
#PARAMETRIZAR LA ELECCION DE LA METRICA
#Funcion para comparar los modelos previamente evaluados. Esta retorna el mejor modelo y su indice en el arr
#metrics: dataframe que contiene todas las metricas de evaluacion de cada modelo
#indexMetrics = list("ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5)
indexMinValue <- which.min(metrics$RMSE)
bestModel <- metrics[indexMinValue,]
row.names(resultMetrics[indexMinValue,])
return(list(bestModel = bestModel, indexMinValue = indexMinValue))
}
#Start
globalParams <- setParams(productName = 'Queso costeño',
frequencyTs = 365.25/7,
startTs = decimal_date(ymd("2020-02-01")))
if(init(globalParams = globalParams)){
data <- loadData()
data <- filterData(globalParams$product)
data <- prepareData()
# Mientras tanto
#lo de abajo reemplazarlo con createdataframe una vez se descargue full data y evitar el error
#data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
splitDataResult <- splitData(data = data.ts, percentage = .3)
train <- splitDataResult$train
test <- splitDataResult$test
h <- splitDataResult$h
th <- splitDataResult$th
results <- trainingModelsMoving(h, th, data.ts)
resultMetrics <- evaluateModels(results, test)
bestModelo <- compareModels(results)
#percentage <- .3
#h <- round(length(data.ts) * percentage)
#th <- length(data.ts) - h
}else{
print('Some parameter is missing')
#api.response(200, 'data is missing')
return(FALSE)
}
resultMetrics
compareModels <- function(metrics){
#PARAMETRIZAR LA ELECCION DE LA METRICA
#Funcion para comparar los modelos previamente evaluados. Esta retorna el mejor modelo y su indice en el arr
#metrics: dataframe que contiene todas las metricas de evaluacion de cada modelo
#indexMetrics = list("ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5)
indexMinValue <- which.min(metrics$RMSE)
bestModel <- metrics[indexMinValue,]
row.names(resultMetrics[indexMinValue,])
return(list(bestModel = bestModel, indexMinValue = indexMinValue))
}
bestModel <- compareModels(results)
bestModel <- compareModels(results)
