#1. product, 2. frequency, 3. start
flag = FALSE
if(is.na(globalParams$product) || is.na(globalParams$frequency) || is.na(globalParams$start)){
print('PARAR LA EJECUCION')
flag = FALSE
}else{
print('Everything is ok! Has fun!')
flag = TRUE
}
return(flag)
}
# Load Data
loadData <- function(){
# Capturar con soap
# Funcion para cargar los datos
data <- read_csv2('datasemanal.csv', locale = locale(encoding = "Latin1"))
data
}
# Filter Data
filterData <- function(productName){
# Filtramos por nombre.
data <- data %>% filter(artiNombre == productName)
data
}
prepareData <- function(){
data <- data %>% mutate(
artiId = as.character(artiId),
artiNombre = as.character(artiNombre),
fechaIni = lubridate::as_date(fechaIni),
maximoKg = as.double(maximoKg),
minimoKg = as.double(minimoKg),
promedioKg = as.double(promedioKg)
)
#Sort
data <- data %>% arrange(fechaIni)
data
}
createTimeSeries <- function(target, globalParamsP){
#target: variable objeto de estudio
data.ts <- ts(data[,target], start = globalParamsP$start, frequency = globalParamsP$frequency)
data.ts
}
#Start
globalParams <- setParams(productName = 'Queso costeño', frequencyTs = 365.25/7, startTs = decimal_date(ymd("2020-02-01")))
if(init(globalParams = globalParams)){
data <- loadData()
data <- filterData(globalParams$product)
data <- prepareData()
}else{
print('Some parameter is missing')
return(FALSE)
}
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.xts <- xts(data$promedioKg, order.by = data$fechaIni)
periodicity(data.ts)
plot(data.xts)
decompose(data.ts)
percentage <- .3
h <- round(length(data.ts) * percentage)
th <- length(data.ts) - h
train <- data.xts[1:th,]
periodicity(train)
test <- data.xts[(th+1):(th+h),]
periodicity(test)
mediaMovil <- function(window, orderP, hP){
fcst <- tail(forecast(ma(window, order = orderP), h = hP)$mean, 1)
return(fcst)
}
data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
for(i in 1:h){
ventana <- subset(data.ts, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
accuracy(suavizacionExponencialSimple, test)
trainingModels <- function(h, th, data){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(ses.f, test)["Test set", wmetrics],
))
}
trainingModels(h, th, data.ts)
results <- trainingModels(h, th, data.ts)
results
results
trainingModels <- function(h, th, data, test){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(suavizacionExponencialSimple, test)["Test set", wmetrics],
))
}
results <- trainingModels(h, th, data, test)
results
trainingModels <- function(h, th, data, test){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(suavizacionExponencialSimple, test)["Test set", wmetrics],
))
}
results <- trainingModels(h, th, data.ts, test)
results
# Global Variables (Params)
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
trainingModels <- function(h, th, data, test, metrics){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(suavizacionExponencialSimple, test)["Test set", metrics],
))
}
results <- trainingModels(h, th, data.ts, test, metrics)
results
trainingModels <- function(h, th, data, test, metrics){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(suavizacionExponencialSimple, test)["Test set", metrics],
))
}
results <- trainingModels(h, th, data.ts, test, metrics)
metrics
trainingModels <- function(h, th, data, test, metrics){
suavizacionExponencialSimple <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = h)$mean
}
return(list(
'suavizacionExponencialSimple' = accuracy(suavizacionExponencialSimple, test)["Test set", metrics]
))
}
results <- trainingModels(h, th, data.ts, test, metrics)
results
results$suavizacionExponencialSimple['MSE']
results$suavizacionExponencialSimple
results$suavizacionExponencialSimple$ME
results$suavizacionExponencialSimple[]
results$suavizacionExponencialSimple[1]
indexMetrics = list(
"ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5
)
indexMetrics = list(
"ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5
)
indexMetrics$ME
results$suavizacionExponencialSimple[indexMetrics$RMSE]
min(result)
min(results)
results[1]
min(results[1:3])
results[1]
results[1][1]
results[1][1]
results[1][2]
results[1][1][1]
#Entrenar modelos con ventana movil
trainingModelsMovil <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal,
'holtWinterAditivo' = holtWinterAditivo,
'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModels(h, th, data.ts)
library(tidyverse)
library(lubridate)
library(xts)
library(forecast)
# Global Variables (Params)
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
indexMetrics = list(
"ME" = 1, "RMSE" = 2, "MAE" = 3, "MPE" = 4, "MAPE" = 5
)
setParams <- function(productName = NA, frequencyTs = NA, startTs = NA){
# Funcion para establecer los parametros globales
# productName: nombre del producto
# frequencyTs: periodicidad de la serie de tiempo
# startTs: fecha de inicio de la serie de tiempo
product <- productName
frequency <- frequencyTs
start <- startTs
return(list(product = product, frequency = frequency, start = start))
}
init <- function(globalParams){
# Funcion para validar que hayan llegado todos los parametros
#globalParams: vector que contiene los parametros globales obligatorios
#1. product, 2. frequency, 3. start
flag = FALSE
if(is.na(globalParams$product) || is.na(globalParams$frequency) || is.na(globalParams$start)){
print('PARAR LA EJECUCION')
flag = FALSE
}else{
print('Everything is ok! Has fun!')
flag = TRUE
}
return(flag)
}
# Load Data
loadData <- function(){
# Capturar con soap
# Funcion para cargar los datos
data <- read_csv2('datasemanal.csv', locale = locale(encoding = "Latin1"))
data
}
# Filter Data
filterData <- function(productName){
# Filtramos por nombre.
data <- data %>% filter(artiNombre == productName)
data
}
prepareData <- function(){
data <- data %>% mutate(
artiId = as.character(artiId),
artiNombre = as.character(artiNombre),
fechaIni = lubridate::as_date(fechaIni),
maximoKg = as.double(maximoKg),
minimoKg = as.double(minimoKg),
promedioKg = as.double(promedioKg)
)
#Sort
data <- data %>% arrange(fechaIni)
data
}
createTimeSeries <- function(target, globalParamsP){
#target: variable objeto de estudio
data.ts <- ts(data[,target], start = globalParamsP$start, frequency = globalParamsP$frequency)
data.ts
}
#Start
globalParams <- setParams(productName = 'Queso costeño', frequencyTs = 365.25/7, startTs = decimal_date(ymd("2020-02-01")))
if(init(globalParams = globalParams)){
data <- loadData()
data <- filterData(globalParams$product)
data <- prepareData()
}else{
print('Some parameter is missing')
return(FALSE)
}
data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
percentage <- .3
h <- round(length(data.ts) * percentage)
th <- length(data.ts) - h
train <- data.xts[1:th,]
train <- data.xt[1:th,]
test <- data.xt[(th+1):(th+h),]
train <- data.ts[1:th,]
periodicity(train)
test <- data.ts[(th+1):(th+h),]
periodicity(test)
#Entrenar modelos con ventana movil
trainingModelsMovil <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal,
'holtWinterAditivo' = holtWinterAditivo,
'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModels(h, th, data.ts)
#Entrenar modelos con ventana movil
trainingModelsMoving <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal,
'holtWinterAditivo' = holtWinterAditivo,
'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModelsMoving(h, th, data.ts)
results
results <- trainingModelsMoving(h, th, data.ts)
data.ts
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = globalParamsP$start, frequency = globalParamsP$frequency)
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = globalParams$start, frequency = globalParams$frequency)
data.ts
percentage <- .3
h <- round(length(data.ts) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = (2020,2,1), frequency = 52)
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = c(2020,2,1), frequency = 52)
data.ts
percentage <- .3
h <- round(length(data.ts) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = c(2020,2), frequency = 52)
data.ts
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- ts(data$promedioKg, start = c(2020,2,1), frequency = 52)
data.ts
#REVISAR ESTO. DA PROBLEMA
#Da problema al mirar la periodicidad
#Error in try.xts(x, error = "'x' needs to be timeBased or xtsible") :
#'x' needs to be timeBased or xtsible
#data.ts <- createTimeSeries(target = 'promedioKg', globalParamsP = globalParams)
data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
data.ts
h <- round(length(data.ts) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
periodicity(train)
test <- data.ts[(th+1):(th+h),]
periodicity(test)
#Entrenar modelos con ventana movil
trainingModelsMoving <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
#holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal,
#'holtWinterAditivo' = holtWinterAditivo,
'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModelsMoving(h, th, data.ts)
#Entrenar modelos con ventana movil
trainingModelsMoving <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
#holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
#holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal,
#'holtWinterAditivo' = holtWinterAditivo,
#'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModelsMoving(h, th, data.ts)
results
#Entrenar modelos con ventana movil
trainingModelsMoving <- function(h, th, data){
suavizacionExponencialSimple <- NULL
suavizacionExponencialLineal <- NULL
holtWinterAditivo <- NULL
holtWinterMultiplicativo <- NULL
for(i in 1:h){
ventana <- subset(data, start = 1, end = th - 1 + i)
suavizacionExponencialSimple[i] <- ses(ventana, h = 1)$mean
suavizacionExponencialLineal[i] <- holt(ventana, h = 1)$mean
#holtWinterAditivo[i] <- hw(ventana, h = 1, seasonal = "additive")$mean
#holtWinterMultiplicativo[i] <- hw(ventana, h = 1, seasonal = "multiplicative")$mean
}
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal
#'holtWinterAditivo' = holtWinterAditivo,
#'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
}
results <- trainingModelsMoving(h, th, data.ts)
return(list(
'suavizacionExponencialSimple' = suavizacionExponencialSimple,
'suavizacionExponencialLineal' = suavizacionExponencialLineal
#'holtWinterAditivo' = holtWinterAditivo,
#'holtWinterMultiplicativo' = holtWinterMultiplicativo,
))
results
results$suavizacionExponencialSimple
test
evaluateModels <- function(models, test){
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
r <- rbind(accuracy(models$suavizacionExponencialSimple, test)["Test set", metrics],
accuracy(models$suavizacionExponencialLineal, test)["Test set", metrics])
return(r)
}
resultMetrics <- evaluateModels(results, test)
resultMetrics
evaluateModels <- function(models, test){
metrics <- c("ME", "RMSE", "MAE", "MPE", "MAPE")
r <- rbind(accuracy(models$suavizacionExponencialSimple, test)["Test set", metrics],
accuracy(models$suavizacionExponencialLineal, test)["Test set", metrics])
metricas <- data.frame(r)
row.names(metricas) <- c("SES", "HOLT")
return(metricas)
}
resultMetrics <- evaluateModels(results, test)
resultMetrics
resultMetrics$RMSE
min(resultMetrics$RMSE)
which.min(resultMetrics$RMSE)
resultMetrics[1]
resultMetrics[2]
resultMetrics[,1]
resultMetrics[1,]
resultMetrics[1,]
row.name(resultMetrics[1,])
row.names(resultMetrics[1,])
splitData <- function(data, percentage = .3){
h <- round(length(data) * percentage)
th <- length(data.ts) - h
train <- data.ts[1:th,]
test <- data.ts[(th+1):(th+h),]
return(list(train = train, test = test, h = h, th = th))
}
# Mientras tanto
#lo de abajo reemplazarlo con createdataframe una vez se descargue full data y evitar el error
#data.ts <- xts(data$promedioKg, order.by = data$fechaIni)
splitDataResult <- splitData(data = data.ts, percentage = .3)
splitDataResult
prueba <- msts(data.ts, seasonal.periods=c(365,25))
prueba
periodicity(prueba)
plot(prueba)
decompose(prueba)
data.ts
